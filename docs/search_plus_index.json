{"./":{"url":"./","title":"はじめに","keywords":"","body":"コストも時間も削減？！RSpec for Rails × AWS Codebuildで業務で使える 自動テストを体験しよう！ "},"Section_1.html":{"url":"Section_1.html","title":"1.本日のミートアップの内容","keywords":"","body":"本日のミートアップの内容 本日のゴール RSpecでできること・できないことが分かる。 現場で使えるRSpecの使い方が分かる。 RSpecを使うメリットとデメリットが分かるようになる。 本日お話しすること Rspecの概要解説 RSpecでの単体・結合・統合テスト > AWS CodeBuildでビルド実行する 本日のミートアップ対象者 RSpecの導入を検討している人 Railsで開発してるが、Rpsecを書いたことない人 Railsで開発してるが、Rpsecをこれから利用する人(開発経験2年目~5年目) 留意事項 xxxxx xxxxx "},"Section_2.html":{"url":"Section_2.html","title":"2.RSpecの概要解説","keywords":"","body":"RSpecの概要解説 本セクションで行うこと RSpecとは何か RSpecのメリット・デメリット RSpecでできること RSpecとは？ 突然ですが、皆さんの開発現場ではテストはどのように実施されてますか？ 私が経験した現場では、色々なテストの形がありました。動作確認≒テストになっている、エクセルにエビデンスのキャプチャを張って行うレガシーなテスト、テストコードを書いて行う自動テスト、、、、、など現場によって様々です。 公式ドキュメントよりRSpecについて下記のように説明されています。 RSpec is a Behaviour-Driven Development tool for Ruby programmers. BDD is an approach to software development that combines Test-Driven Development, Domain Driven Design, and Acceptance Test-Driven Planning. RSpec helps you do the TDD part of that equation, focusing on the documentation and design aspects of TDD. 一言で言うと、RSpecは、（Rubyプログラマー為の）BDDツールである。 BDD・・・振る舞い駆動開発(Behaviour-Driven Development)のこと。TDD（テスト駆動開発）から派生した開発手法。BDDでは実装前に要求される振る舞い(≒仕様)をテストに書き出してから実装し、また、要求される振る舞いは自然言語(英語など)に近い形で表現されます。 RailsプロジェクトでRSpecを利用するには「rspec-rails」というライブラリ（gem）のインストールが必要になります。 RSpecのメリット・デメリット RSpecを導入することで、以下のようなメリットがあります。 メリット テストのコストが抑えられる例）エクセルにテスト仕様書を書き出す場合、、、 RSpecを利用すると、テスト実施はRSpecが行う 誰がやっても同じテストが実施される為、テストのQAが安定する テスト実施や仕様書の工数を削減できる（中長期なメリット）一度テストコードを書くと、その後の追加開発時で既存プログラムへのテスト工数が以下のように削減できる 追加開発時のデグレ発生を防止できる（中長期なメリット） デメリット RSpecの学習コストが必要 開発時にテストコードも書くので、開発自体の工数が増加する RSpecでできること 単体テストができる 結合テストができる 統合テストができる "},"Section_3.html":{"url":"Section_3.html","title":"3.単体テスト(UT)","keywords":"","body":"単体テスト 本セクションで行うこと RSpecの導入方法 Modelの単体テストの実装 APIの単体テスト 1. RSpecの導入方法 まずはRSpecをinstallしていきます。Gemfileに追加します。 Gemfile group :development, :test do # 省略 gem 'rspec-rails' #←追加 end Gemfileにgem 'rspec-rails'を追加したらbundle installしていきます。 ターミナル bundle install 終了したら、ジェネレーターを使用してRSpecのinstallを完了させます。 ターミナル rails g rspec:install 下記のようにディレクトリ・ファイルが作成されれば完了です。 create .rspec create spec create spec/spec_helper.rb create spec/rails_helper.rb ※RSpecの設定は各種ありますが、今回は割愛します。 2. Modelの単体テストの実装 モデルスペックの観点 モデルスペックでは以下のような観点で実装をします。 有効な属性で初期化した場合、モデルが有効であることを検証する。 無効な属性で初期化した場合、モデルが有効ではないことを検証する。 クラスメソッドとインスタンスメソッドが定義されている場合は期待通りに動作すること。 ファイルの作成 まずはUserモデルを例にファイル作成をしていきます。 ターミナル rails g rspec:model user spec/models/user_spec.rbというファイルが作成されていればOKです。 Userモデルの要件 ではモデルスペックの観点を参考に、Userモデルでのテスト要件をまとめます。 先ほど作成したuser_spec.rbファイルに必要なテストを以下のように記載しました。 require 'rails_helper' RSpec.describe User, type: :model do # 有効な属性の場合のテスト it \"nickname, email, password, password_confirmationがあれば有効であること\" # アソシエーションのテスト it \"postモデルとのアソシエーションが有効であること\" it \"commentモデルとのアソシエーションが有効であること\" # 各属性の有効・無効の場合のテスト it \"nicknameがnilの場合、無効であること\" it \"nicknameが空文字の場合、無効であること\" it \"nicknameが既に保存されている場合、無効であること\" it \"nicknameが10文字以内の場合、有効であること\" it \"nicknameが11文字以上の場合、無効であること\" it \"emailがnilの場合、無効であること\" it \"emailが空文字の場合、無効であること\" it \"emailが既に保存されている場合、無効であること\" it \"emailがemailの形式ではない場合、無効な状態であること\" it \"emailは全角文字を使用する場合、無効な状態であること\" do it \"passwordがnilの場合、無効であること\" it \"passwordが空文字の場合、無効であること\" it \"passwordが5文字以内の場合、無効であること\" it \"passwordが6文字以上の場合、有効であること\" it \"passwordが128文字以内の場合、有効であること\" it \"passwordが129文字以上の場合、無効であること\" it \"password_confirmationがnilの場合、無効であること\" it \"password_confirmationが空文字の場合、無効であること\" it \"passwordとpassword_confirmationが不一致の場合、無効であること\" end このようにテストを書き始める際はまずはどのような観点が必要なのか洗い出してexampleとしてまとめると実装がしやすいです。 上記の文法を説明していきます。 describe 期待する結果をまとめます。上記では describe Userとしていて、これがUserモデルのテストであると明示しています。 これはネストすることが可能で、describeの中にdescribeを実装することもできます。 it 実際のテストを実行するexampleを定義しています。 基本的にexample一つにつき一つの結果を期待しています。 exampleは明示的に記載します。省略することもできますが、可読性が落ちるため、基本的には記述することが望ましいです。 exampleの説明は動詞で始まります。例えば、nicknameがnilの場合、無効であることを英語に置き換えるとis invalid if nickname is nilとなり、動詞から始まっていることがわかります。 テストを実装する では、実際にテストを実装していきます。まずは、「有効な属性の場合のテスト」から実装しましょう。 有効な属性の場合のテスト require 'rails_helper' RSpec.describe User, type: :model do # 有効な属性の場合のテスト it \"nickname, email, password, password_confirmationがあれば有効であること\" do user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end end まず、it ~ do endでexampleのブロックを作成ます。今回は有効な属性のテストのため、exampleとしてit \"nickname, email, password, password_confirmationがあれば有効であること\" do endとしています。こうすることで、このテストが何をテストするのか非常にわかりやすくなります。 続いて、itの中身を見てみましょう。最初にUserモデルのインスタンスを作成しています。 今回は、すべての属性が有効である場合のテストのため、全ての属性が有効であるインスタンスを作成します。 user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) 最後に、本当にこのインスタンスが有効であるかどうかをチェックします。 expect(user).to be_valid 上記が実際のテストの実行構文です。 まずはこのテストが通るかどうか実行してみます。 ターミナル bundle exec rspec spec/models/user_spec.rb 下記のようにターミナルに出力されればテスト成功です！ User nickname, email, password, password_confirmationがあれば有効であること Finished in 0.29163 seconds (files took 6.71 seconds to load) 1 example, 0 failures では、expect(user).to be_validが実際に何をやっているか一つずつ見ていきましょう。 expectメソッドとマッチャ テストにはexpectメソッドを使用すします。expectとは日本語で「〜を期待する」という意味で、「テスト結果が〜になることを期待する」ということを表しています。 expectは引数をとり、その引数がどのような状態になっていることを期待するのかによってさまざまなマッチャと組み合わせて使用します。 マッチャとは、期待値と実際の値を比較して、一致したかもしくは一致していないかを返すオブジェクトのことです。 今回のケースではbe_validというマッチャを使用していて、このマッチャは「〜は有効である」ことを示しています。 つまり、expect(user).to be_validは「userインスタンスが有効であることを期待する」テストであるということです。 このようにRSpecのテストでは基本的にexpectとマッチャを使用して、期待した結果が得られるかどうかテストしていきます。 ではここで、失敗テストも実行してみましょう。 「userインスタンスが有効であることを期待する」テストなので、失敗するテストとは、ここでは「userインスタンスが有効でないことを期待する」テストのこととします。 次のようにソースを変更します。 expect(user).to_not be_valid 先ほどと比べるとtoがto_notとなっています。 toが「〜となることを期待する」を示しているのに対し、to_notは「〜とならないことを期待する」を示しています。 この状態でもう一度テストを実行してみましょう。 ターミナル bundle exec rspec spec/models/user_spec.rb 下記のようにターミナルに出力されれば期待通りのテスト結果。 User nickname, email, password, password_confirmationがあれば有効であること (FAILED - 1) Failures: 1) User nickname, email, password, password_confirmationがあれば有効であること Failure/Error: expect(user).to_not be_valid expected # not to be valid # ./spec/models/user_spec.rb:11:in `block (2 levels) in ' Finished in 0.09446 seconds (files took 4.89 seconds to load) 1 example, 1 failure Failed examples: rspec ./spec/models/user_spec.rb:4 # User nickname, email, password, password_confirmationがあれば有効であること 上記のFailure/Error: expect(user).to_not be_validのように、expect(user).to_not be_validがエラーとなって、テストが失敗しています。 validationのテスト 続いてvalidationのテストを実装していきます。 今回のUserモデルでは下記のようなvalidationを実装しています。 validates :nickname, presence: true, uniqueness: true, length: { maximum: 10 } validates :password_confirmation, presence: true また、このほかにユーザーの認証にはdeviseを使用しているため、deviseが設定しているvalidationが内部的に存在しています。 （例えばemailがnil or 空文字だと無効など) ここではnicknameのvalidationテストを実装してみます。 nicknameのvalidationは下記の通り. validates :nickname, presence: true, uniqueness: true, length: { maximum: 10 } nilまたは空文字の場合は無効 (presence: true) 同じnicknameは保存できない (uniqueness: true) 文字数は最大で10文字 以上のことから、テストすべき観点は下記が想定されます。 it \"nicknameがnilの場合、無効であること\" it \"nicknameが空文字の場合、無効であること\" it \"nicknameが既に保存されている場合、無効であること\" it \"nicknameが10文字以内の場合、有効であること\" it \"nicknameが11文字以上の場合、無効であること\" では実際にテストを実装してみましょう。 require 'rails_helper' RSpec.describe User, type: :model do # 有効な属性の場合のテスト ## 省略 describe 'nickname' do it 'nilの場合、無効であること' do user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it '空文字の場合、無効であること' do user = User.new( nickname: \"\", email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do User.create( nickname: 'Takashi', email: 'tester_1@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do user = User.new( nickname: 'TakashiKai', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKaii', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end テストを実行してみます。 ターミナル bundle exec rspec spec/models/user_spec.rb User nickname nilの場合、無効であること 空文字の場合、無効であること すでに使用されているnicknameの場合、保存できないこと 10文字以内の場合、有効であること 11文字以上の場合、無効であること Finished in 1.19 seconds (files took 4.51 seconds to load) 5 examples, 0 failures となっていればテスト成功です。 まず、何をテストするかを明示的に示すため、describeを使用します。 describe 'nickname' do これでこのブロックはnicknameのテストを実装しているんだな、と理解できるようになります。 続いてexampleについて、'nilの場合、無効であること'を例に解説していきます。 it 'nilの場合、無効であること' do user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end 以前のテスト同様に、まずはuserインスタンスを作成しますが、今回は「nicknameがnilの場合」をテストしたいため、 nicknameをnilの状態でインスタンスを作成します。 user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) そしてvalid?メソッドを使用してuserインスタンスが有効かどうかを判定します。 user.valid? valid?メソッドは対象のオブジェクトが有効な場合はtrue、無効な場合はfalseを返し、falseの場合はerrorsの中にエラー内容を格納します。 そのエラー内容が意図したものになっているかテストをしています。 expect(user.errors[:nickname]).to include(\"を入力してください\") ※今回のアプリはエラーを日本語化しているため、「を入力してください」という少しわかりづらいメッセージになっています。 英語の場合は「can't be blank」となります。 このテストで使用しているマッチャはincludeで、引数に取ったものがexpectの引数のものに含まれているか検証しています。 ここで一つ疑問が発生します。 user.valid?でuserが無効な場合、falseを返すのであれば、「user.valid?がfalseであることを期待する」というテストではダメなのか？ 下記のようなテストでも良いように見えますね。 it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKaii', # 11文字 email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user.valid?).to eq(false) end expectの引数にuser.valid?をとり、eqマッチャを使用してuser.valid?がfalseであることを期待するというテストです。 こちらの方が先ほどのテストの方よりも一行短くなります。しかも、このテストは通ります。 では下記の場合はどうなるか考えてみましょう。 it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKai', #間違えて10文字 email: '',　　 #間違えてブランク password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user.valid?).to eq(false) end （極端なケースですが）上記のテストはnicknameは11文字以上である場合をテストしたいのに10文字になっていますが、 emailが無効な値のため、user.valid?はfalseになり、テストが通ってしまいます。 これでは「11文字以上の場合、無効であること」をテストしたことにはなりません。 今回のアプリのUserモデルのようなテストであれば記述量は少ないため、発生しにくいですが、アプリが巨大化するにつれてこのようなテスト自体のミスは必ず増えてきます。 そのときに、テストしようと思ったことが実はテストできておらず、しかもテストが通ってしまうという状況は品質低下につながるため要注意です。 今回の例では適切にエラーを検証するとテストが失敗するため、すぐに異変に気づくことができます。 it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKai', #間違えて10文字 email: '',　　 #間違えてブランク password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end テストを実行すると下記のように失敗します。 User nickname 11文字以上の場合、無効であること (FAILED - 1) Failures: 1) User nickname 11文字以上の場合、無効であること Failure/Error: expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") expected [] to include \"は10文字以内で入力してください\" # ./spec/models/user_spec.rb:66:in `block (3 levels) in ' Finished in 0.67955 seconds (files took 4.55 seconds to load) 1 example, 1 failure Failed examples: rspec ./spec/models/user_spec.rb:58 # User nickname 11文字以上の場合、無効であること expected [] to include \"は10文字以内で入力してください\"とあるようにuser.errors[:nickname]の中身が空のためテストが失敗しています。 （emailでエラーになっているため、user.errors[:nickname]は空でuser.errors[:email]の中にエラーが格納されています） DRYに書く ここまでのテストを見てきて「冗長だな」と感じた方もいらっしゃると思います。 ではRSpecをDRYに書く方法をいくつか紹介していきます。 before 今回のテストではexampleの中で何度もUser.newが登場します。 これを共有化して使用するためにはbeforeを使用します。 まずはソースコードをこのように変更します。 require 'rails_helper' RSpec.describe User, type: :model do before do @user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) end it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(@user).to be_valid end describe 'nickname' do it 'nilの場合、無効であること' do @user.nickname = nil expect(@user.errors[:nickname]).to include(\"を入力してください\") end it '空文字の場合、無効であること' do @user.nickname = \"\" @user.valid? expect(@user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do @user.save user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do @user.nickname = 'TakashiKai' expect(@user).to be_valid end it '11文字以上の場合、無効であること' do @user.nickname = 'TakashiKaii' @user.valid? expect(@user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end beforeは処理を定義すると、その処理が各exampleの実行前に実行されます。 今回の場合はUserインスタンスを作成して@userに代入しています。 テストを実行すると、各exampleの実行前に@userにインスタンスが代入されるため、example内で@userを呼び出すことができます。 あとは各exampleに適したテストを実行するだけです。 beforeのスコープはdescribeやまだ出てきていませんがcontextの中になります。 今回は最上位のdescribe内で定義しているため、すべてのexampleから@userにアクセスできますが、 これを下記のように書き換えてみます。 ## 省略 describe 'nickname' do before do @user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) end ## 省略 このようにdescribe 'nickname' do内にbeforeを定義するとこのdescribe内からしかアクセスできなくなります。 そのため、下記テストは失敗します。 it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(@user).to be_valid end let 続いてletです。変数を作成するメソッドになりますが、変数を作成するタイミングが特徴的です。 宣言した時には作成せず、その変数を呼び出した時に初めて作成されます。 先ほどのbeforeをletに置き換えてみます。 require 'rails_helper' RSpec.describe User, type: :model do let(:user) { User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) } it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(user).to be_valid end describe 'nickname' do it 'nilの場合、無効であること' do user.nickname = nil expect(user.valid?).to eq(false) end it '空文字の場合、無効であること' do user.nickname = \"\" user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do user.save new_user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) new_user.valid? expect(new_user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do user.nickname = 'TakashiKai' expect(user).to be_valid end it '11文字以上の場合、無効であること' do user.nickname = 'TakashiKaii' user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end 上記のように置き換えることができました。 しかし、beforeとの違いやメリットがこのままだとわかりづらいですね。 わかりやすいように今度はPostモデルのテストで解説します。 Postモデルを一旦このように実装しました。 有効な属性の場合のテストのみ実装しています。 require 'rails_helper' describe Post do let(:user) { create(:user, nickname: 'Takashi') } 　　　　　# 有効な属性の場合のテスト it 'text, userがあれば有効であること' do post = Post.new( text: '投稿のテキスト', user: user ) expect(user).to be_valid end end let let! subject テストデータの作成方法(Factorybot、Fackerの導入) 外部APIテスト vcrの使用方法 "},"Section_4.html":{"url":"Section_4.html","title":"4.結合テスト(IT)","keywords":"","body":"結合テスト（IT） 本セクションで行うこと 今回取り上げる結合テストについて Request specの解説 本アプリでの実例紹介（後で変更するかも） 今回取り上げる結合テストについて 結合テストは、Integration Test(統合テスト)とも呼ばれ、システム開発において単体レベルで開発した機能が組み合わさって動作した時、期待される動作をするかどうかをテストします。結合テストは、実施する対象によって内部結合・外部結合に分かれます。 内部結合・・・ システム内部の機能同士を組み合わせてテストを行う外部結合・・・ システム内部の機能とシステム外部の機能を組み合わせてテストを行う 今回取り上げる結合テストは「内部結合」になります 今回の投稿アプリでは、以下３つの機能があります。 ユーザー機能(users_controller)ユーザー作成、ユーザー認証（ログイン・ログアウト） 投稿機能(posts_controller)投稿の新規作成、投稿の編集、投稿の一覧表示、投稿削除 コメント機能(comments_controller)対象の投稿に対してコメントの作成 内部結合では、３つの機能の間の連携部分が期待される動きをするか？というテストをします。 具体的な観点は以下です。 コントローラーへのリクエストが通ること 期待されるレスポンスが返却されること Request specの解説 Request specを使うと、以下のテストができるようになります。 HTTPリクエストのテストができる 複数コントローラーの複数のリクエストがテストできる 複数のセッションでリクエストを指定できる 以下、Request specファイルの生成コマンド rails g rspec:request ファイル名 今回は投稿機能の結合テスト(posts_spec.rb)を例に実際のテストコードを確認していきます。 これから説明するテストの内容は、以下です。ユーザーがログインしている場合は投稿一覧のリクエストが成功すること ①テストデータとして、ログインユーザーと投稿を生成 let(:user) { create(:user, nickname: 'Takashi') } let(:post_instance) { create(:post, user: user, text: 'PostRequestTest', image: 'https://example_image_url') } ②subject(テスト対象のオブジェクト)は、投稿一覧のリクエスト処理Request specでは直接ルーティング名を指定することができます。 subject { get posts_url } ③テスト前にテストデータのユーザーでログイン処理とlet変数（post_instance）を呼び出しておく before do sign_in user post_instance end ④リクストが通ることを確認するので、HTTPレスポンスのステータスが200であることが期待値 it_behaves_like 'return_response_status', 200 次のテスト内容は以下です。投稿一覧のレスポンスに適切な投稿内容を含んでいること ①subject(テスト対象のオブジェクト)は先ほどど同じ、投稿一覧のリクエスト処理 subject { get posts_url } ②返却されたレスポンスのボディに投稿の内容とhtmlを含んでいるか確認します。response.bodyの内容を検証しています。 expect(response.body).to include 'PostRequestTest :Takashiの投稿' expect(response.body).to include '投稿者Takashi' 上記コード全体 let(:user) { create(:user, nickname: 'Takashi') } let(:post_instance) { create(:post, user: user, text: 'PostRequestTest', image: 'https://example_image_url') } describe '投稿一覧' do subject { get posts_url } context 'ログインしている場合' do before do sign_in user post_instance end it_behaves_like 'return_response_status', 200 it 'レスポンスに適切な投稿内容を含むこと' do subject aggregate_failures do expect(response.body).to include 'PostRequestTest :Takashiの投稿' expect(response.body).to include '投稿者Takashi' end end end ~~~~省略~~~~~ "},"Section_5.html":{"url":"Section_5.html","title":"5.システムテスト(ST)","keywords":"","body":"システムテスト(ST) 本セクションで行うこと システムテストについて System spec解説 システムテストについて システムテスト(System Test)は、要件定義書に記載した要件をクリアしているか?、つまりアプリ全体が一つのシステムとして期待される動きをするのか?、　　 を確認するテストになります。これまで説明した単体テスト、結合テストとは、詳細設計、基本設計で記載した要件をクリアしているかどうかを確認していました。このような形のテストモデルを「V字モデル」と呼びます。 では、実際にシステムテストを行う際はどのようにテストケースを実施すれば良いでしょうか?システムテストの手法としていくつかありますが、今回はシナリオテストを行います。 シナリオテストは、実際のユーザーの行動をシナリオ化してテストを行います。投稿機能を例に考えてみましょう。 投稿機能におけるシステムテスト： 1. ユーザーは投稿する 2. ユーザーは投稿の編集をする 3. ユーザーは投稿の削除をする 4. ユーザーは自分の投稿にコメントをする 5. ユーザーは他人の投稿を閲覧し、コメントをする 6. ...以下省略... System spec解説 Rpsecでは、システムテストとして行うテストをSystem specと呼んでいます。 System specでは、ユーザーの動きをコードに起こしてテストする為に、「Capybara」と言うgem(ライブラリ）を使います。Capybaraは、Rails5.1以降では標準インストールされています。Capybaraは、指定したページにアクセスしたり、フィールドに入力したり、ボタンをクリックしたり、ブラウザの操作を可能にします。 先ほどの投稿機能のシステムテストケースを使って、実際のコードを確認していきましょう！ テスト内容：1. ユーザーは投稿する ①投稿する為にユーザーを用意 let(:user_a) { create(:user, nickname: 'Takashi') } ②テスト実施前に、ユーザーのログイン処理を行う before do sign_in_as user_a end ③テスト対象はユーザーは投稿するなので、Capybaraのメソッドでブラウザ操作して投稿処理をする click_link_or_button '投稿する' fill_in 'post_text', with: 'sample_text' click_button 'commit' post = Post.find_by_text_and_user_id('sample_text :Takashiの投稿', user_a.id) 上記では、「投稿する」ボタンを押下して遷移先で、\"sanple_text\"と投稿欄に入力して、投稿ボタンを押下しています。 Capybaraメソッドclick_link_or_button　'対象要素のIDやテキスト'・・・指定したボタンもしくはリンクを探してクリックする。fill_in '対象要素のnameやID', with: 'フィールドに入力する文字'・・・指定した要素を探して、with以降で指定した文字を入力する。click_button　'対象要素のIDやname'・・・指定したボタンを探してクリックする。 ④テスト対象（③）に対して、遷移先のパスが合っているか、投稿した内容を表示しているか、スラック通知処理はできているかを確認 aggregate_failures do expect(current_path).to eq posts_path expect(page).to have_content 'sample_text' expect { SlackSyncJob.perform_later(post) }.to have_enqueued_job.with(post) end Capybaraメソッドcurrent_path・・・現在表示しているページのパスを返す。page・・・現在表示しているページのオブジェクト。 補足：aggregate_failures do...endは、これで囲まれたexpectは、expectの評価で失敗しても次のexpectを実行することができるようになります。これまでのRSpecだと、一つのexampleにつき複数のexpectで書くと失敗した時にそれ以降のexpectが実行されませんでしたが、これにより一つのexpamleに複数のexpectを書くことが出来ます。 "},"Section_6.html":{"url":"Section_6.html","title":"6.AWS CodeBuildでビルドを実行しみよう！","keywords":"","body":"6. AWS CodeBuildでテスト＆ビルドする 本セクションで行うこと AWS CodeBuildの解説 ビルドプロジェクトを作成する CodeBuildでビルドを実行する AWS CodeBuildの解説 AWSで提供されているクラウドサーバー上で、プロジェクトのテストとビルドができるサービス。 Rubyの他にJava、Go, pythonなどに対応。 また、他のサービス（AWS CodeCommitやCodeDeploy）と組み合わせて利用することも可能。 AWS CodeBuildの仕組み AWS CodeBuildは、「ビルドプロジェクト」を元にビルドを行う。 ビルドプロジェクト・・・ソースコードの指定やビルド環境の指定などビルドに関わる情報のこと。AWSコンソールから作成できる。 AWS CodeBuildの処理の流れ AWSコンソールからCodeBuildを実行すると、以下の流れでビルドが行われる。 ビルドプロジェクトに基づきビルド環境を作成 ビルド環境で、ソースコードをダウンロード後、buildspec.ymlで設定したコマンドを実行してソースのコンパイル・テスト・ビルドを行う。 ビルド出力がある場合は、S3にデプロイ可能なアーティファクトをアップロードされる。 １〜３のログは、AWS CloudWatch Logsに送信される。 buildspec.yml ビルド環境で実行するコマンドなどを記載するyaml形式のファイル。 version: 0.2 ・・・buildspecのバージョンを指定（最新の0.2を使用） phases: install: ・・・インストールの段階で実行するコマンドを設定する。主にビルド環境で使用するパッケージのインストールなどに使用。 runtime-versions: docker: 19 ・・・ 今回はdockerを使用しているのでdockerのバージョン19を指定（※１）。 commands: pre_build: ・・・・ビルドの前に実行するコマンドを設定する。主にnpmパッケージのインストールやgemのインストールなどに使用。 - echo PRE_BUILD Start - docker-compose -f docker_compose_test.yml build ・・・　dockerをビルドする。 build: ・・・ビルド時に実行するコマンドを設定する。主にテストを行う。 commands: - echo BUILD start - docker-compose -f docker_compose_test.yml up -d - docker-compose -f docker_compose_test.yml run app bundle exec rake spec ・・・テストを実行する。 ※１バージョンはこちらを参照 ビルドプロジェクトを設定する 実際の現場では、テスト環境用のDBが用意されていることがあると思います。Codebuildは、VPC内に設置することも可能です。同じVPC内にRDSを設置することでCodeBuildからRDSに接続してテストを実行することができます。今回は実際の現場で使えそうな利用方法として、テスト用のRDSに接続してビルドを実行したいと思います。 今回使用するAWSのアーキテクトの確認 ポイント VPCのパブリックサブネットにはNatGatewayを設置し、インターネット接続を可能にしておく CodeBuildとRDSはプライベートサブネットに設置する RDSのセキュリティグループに、CodeBuildに設定しいるセキュリティグループからのアクセスを追加する。（この設定によってCodeBuildはRDSに接続可能になる） ビルドプロジェクトの作成 ビルドプロジェクトでVPCを指定する必要があるので、事前にVPC・サブネット・RDSを作成しておきましょう。AWS Codebuildのビルドプロジェクトの作成画面です。 プロジェクト名・・・ プロジェクト名を指定する（今回はmirameetVol28) ソースプロバイダ・・・GitHubやBitbucketなど　ソース共有ツールを指定する（今回はGitHub) リポジトリ・・・ソースのリポジトリの種別（PublicリポジトリかPrivateリポジトリか）を選択（今回のmirameetVol28はパブリックリポジトリ） GitHubリポジトリ・・・対象のリポジトリを選択 環境イメージ・・・AWSの用意している環境かDockerを指定する オペレーティングシステム・・・OSを指定する（今回は、Ubuntu) ランタイム・・・ランタイムを選択（Standardを選択） イメージ・・・イメージを選択(aws/codebuild/standard:4.0) 特権付与・・・docker-composeでビルドする際はtチェックを入れる VPC・・・事前に作成したVPCを選択 サブネット・・・プライベートサブネットを選択 セキュリティグループ・・・CodeBuild用のセキュリティグループを選択 環境変数・・・環境変数を設定（ビルド環境に設定される） ビルド仕様・・・ビルドコマンドの設定（今回はBuildspecファイルを使用する） 最後に、ビルドプロジェクトを作成するをクリックして作成します！ CodeBuildでビルドを実行する ビルドプロジェクト一覧から、プロジェクをクリック 「ビルドを開始」ボタンをクリック ビルドには、５分ほどかかります。 "}}