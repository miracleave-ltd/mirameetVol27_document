{"./":{"url":"./","title":"はじめに","keywords":"","body":"コストも時間も削減？！RSpec for Rails × AWS Codebuildで業務で使える 自動テストを体験しよう！ "},"Section_1.html":{"url":"Section_1.html","title":"1.本日のミートアップの内容","keywords":"","body":"本日のミートアップの内容 本日のゴール 1.1. RSpecでできること・できないことが分かる。 1.2. 現場で使えるRSpecの使い方が分かる。 1.3. RSpecを使うメリットとデメリットが分かるようになる。 本日お話しすること 2.1. RSpecの概要解説 2.2. RSpecでの単体・結合・システムテスト 　 ※本日お話ししませんが、>AWS CodeBuildでビルド実行方法のハンズオン資料をご用意しております。　　 本日のミートアップ対象者 3.1. RSpecの導入を検討している人 3.2. Railsで開発してるが、RSpecを書いたことがない人 3.3. Railsで開発してるが、RSpecをこれから利用する人(開発経験2年目~5年目) 3.4. Railsはやったことないが、自動テストコードに興味がある人 "},"Section_2.html":{"url":"Section_2.html","title":"2.RSpecの概要解説","keywords":"","body":"RSpecの概要解説 本セクションで行うこと RSpecとは何か RSpecのメリット・デメリット RSpecでできること RSpecとは？ 突然ですが、皆さんの開発現場ではテストはどのように実施されてますか？ 私が経験した現場では、色々なテストの形がありました。動作確認≒テストになっている、エクセルにエビデンスのキャプチャを貼って行うレガシーなテスト、テストコードを書いて行う自動テスト、、、、、など現場によって様々です。 公式ドキュメントよりRSpecについて下記のように説明されています。 RSpec is a Behaviour-Driven Development tool for Ruby programmers. BDD is an approach to software development that combines Test-Driven Development, Domain Driven Design, and Acceptance Test-Driven Planning. RSpec helps you do the TDD part of that equation, focusing on the documentation and design aspects of TDD. 一言で言うと、RSpecは、（Rubyプログラマーの為の）BDDツールである。 BDD・・・振る舞い駆動開発(Behaviour-Driven Development)のこと。TDD（テスト駆動開発）から派生した開発手法。BDDでは実装前に要求される振る舞い(≒仕様)をテストに書き出してから実装し、また、要求される振る舞いは自然言語(英語など)に近い形で表現されます。 RailsプロジェクトでRSpecを利用するには「rspec-rails」というライブラリ（gem）のインストールが必要になります。 RSpecのメリット・デメリット RSpecを導入することで、以下のようなメリットがあります。 メリット テストのコストが抑えられる例）エクセルにテスト仕様書を書き出す場合、、、 RSpecを利用すると、テスト実施はRSpecが行う (グレーアウトしている工程は削減できる工程) テスト実施や仕様書の工数を削減できる（中長期なメリット）一度テストコードを書くと、その後の追加開発時で既存プログラムへのテスト工数が以下のように削減できる(グレーアウトしている工程は削減できる工程) 追加開発時のデグレ発生を防止できる（中長期なメリット） 開発者は品質を保ちながらも開発が行える（開発しながらテストを実行することができるので、バグやデグレに気付きやすくなる為） 誰がやっても同じテストが実施される為、テストのQAが安定する デメリット RSpecの学習コストが必要 開発時にテストコードも書くので、開発自体の工数が増加する RSpecでできること 単体テストができる 結合テストができる システムテストができる "},"Section_3.html":{"url":"Section_3.html","title":"3.単体テスト(UT)","keywords":"","body":"単体テスト 本セクションで行うこと RSpecの導入方法 Modelの単体テストの実装 APIの単体テスト 1. RSpecの導入方法 まずはRSpecをinstallしていきます。Gemfileに追加します。 Gemfile group :development, :test do # 省略 gem 'rspec-rails' #←追加 end Gemfileにgem 'rspec-rails'を追加したらbundle installしていきます。 ターミナル bundle install 終了したら、ジェネレーターを使用してRSpecのinstallを完了させます。 ターミナル rails g rspec:install 下記のようにディレクトリ・ファイルが作成されれば完了です。 create .rspec create spec create spec/spec_helper.rb create spec/rails_helper.rb ※RSpecの設定は各種ありますが、今回は割愛します。 2. Modelの単体テストの実装 モデルスペックの観点 モデルスペックでは以下のような観点で実装をします。 有効な属性で初期化した場合、モデルが有効であることを検証する。 無効な属性で初期化した場合、モデルが有効ではないことを検証する。 クラスメソッドとインスタンスメソッドが定義されている場合は期待通りに動作すること。 ファイルの作成 まずはUserモデルを例にファイル作成をしていきます。 ターミナル rails g rspec:model user spec/models/user_spec.rbというファイルが作成されていればOKです。 Userモデルの要件 ではモデルスペックの観点を参考に、Userモデルでのテスト要件をまとめます。 先ほど作成したuser_spec.rbファイルに必要なテストを以下のように記載しました。 require 'rails_helper' RSpec.describe User, type: :model do # 有効な属性の場合のテスト it \"nickname, email, password, password_confirmationがあれば有効であること\" # アソシエーションのテスト it \"postモデルとのアソシエーションが有効であること\" it \"commentモデルとのアソシエーションが有効であること\" # 各属性の有効・無効の場合のテスト it \"nicknameがnilの場合、無効であること\" it \"nicknameが空文字の場合、無効であること\" it \"nicknameが既に保存されている場合、無効であること\" it \"nicknameが10文字以内の場合、有効であること\" it \"nicknameが11文字以上の場合、無効であること\" it \"emailがnilの場合、無効であること\" it \"emailが空文字の場合、無効であること\" it \"emailが既に保存されている場合、無効であること\" it \"emailがemailの形式ではない場合、無効な状態であること\" it \"emailは全角文字を使用する場合、無効な状態であること\" it \"passwordがnilの場合、無効であること\" it \"passwordが空文字の場合、無効であること\" it \"passwordが5文字以内の場合、無効であること\" it \"passwordが6文字以上の場合、有効であること\" it \"passwordが128文字以内の場合、有効であること\" it \"passwordが129文字以上の場合、無効であること\" it \"password_confirmationがnilの場合、無効であること\" it \"password_confirmationが空文字の場合、無効であること\" it \"passwordとpassword_confirmationが不一致の場合、無効であること\" end このようにテストを書き始める際はまずはどのような観点が必要なのか洗い出してexampleとしてまとめると実装がしやすいです。 上記の文法を説明していきます。 describe 期待する結果をまとめます。上記では describe Userとしていて、これがUserモデルのテストであると明示しています。 これはネストすることが可能で、describeの中にdescribeを実装することもできます。 it 実際のテストを実行するexampleを定義しています。 基本的にexample一つにつき一つの結果を期待しています。 exampleは明示的に記載します。省略することもできますが、可読性が落ちるため、基本的には記述することが望ましいです。 exampleの説明は動詞で始まります。例えば、nicknameがnilの場合、無効であることを英語に置き換えるとis invalid if nickname is nilとなり、動詞から始まっていることがわかります。 テストを実装する では、実際にテストを実装していきます。まずは、「有効な属性の場合のテスト」から実装しましょう。 有効な属性の場合のテスト require 'rails_helper' RSpec.describe User, type: :model do # 有効な属性の場合のテスト it \"nickname, email, password, password_confirmationがあれば有効であること\" do user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end end まず、it ~ do endでexampleのブロックを作成ます。今回は有効な属性のテストのため、exampleとしてit \"nickname, email, password, password_confirmationがあれば有効であること\" do endとしています。こうすることで、このテストが何をテストするのか非常にわかりやすくなります。 続いて、itの中身を見てみましょう。最初にUserモデルのインスタンスを作成しています。 今回は、すべての属性が有効である場合のテストのため、全ての属性が有効であるインスタンスを作成します。 user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) 最後に、本当にこのインスタンスが有効であるかどうかをチェックします。 expect(user).to be_valid 上記が実際のテストの実行構文です。 まずはこのテストが通るかどうか実行してみます。 ターミナル bundle exec rspec spec/models/user_spec.rb 下記のようにターミナルに出力されればテスト成功です！ User nickname, email, password, password_confirmationがあれば有効であること Finished in 0.29163 seconds (files took 6.71 seconds to load) 1 example, 0 failures では、expect(user).to be_validが実際に何をやっているか一つずつ見ていきましょう。 expectメソッドとマッチャ テストにはexpectメソッドを使用すします。expectとは日本語で「〜を期待する」という意味で、「テスト結果が〜になることを期待する」ということを表しています。 expectは引数をとり、その引数がどのような状態になっていることを期待するのかによってさまざまなマッチャと組み合わせて使用します。 マッチャとは、期待値と実際の値を比較して、一致したかもしくは一致していないかを返すオブジェクトのことです。 今回のケースではbe_validというマッチャを使用していて、このマッチャは「〜は有効である」ことを示しています。 つまり、expect(user).to be_validは「userインスタンスが有効であることを期待する」テストであるということです。 このようにRSpecのテストでは基本的にexpectとマッチャを使用して、期待した結果が得られるかどうかテストしていきます。 ではここで、失敗テストも実行してみましょう。 「userインスタンスが有効であることを期待する」テストなので、失敗するテストとは、ここでは「userインスタンスが有効でないことを期待する」テストのこととします。 次のようにソースを変更します。 expect(user).to_not be_valid 先ほどと比べるとtoがto_notとなっています。 toが「〜となることを期待する」を示しているのに対し、to_notは「〜とならないことを期待する」を示しています。 この状態でもう一度テストを実行してみましょう。 ターミナル bundle exec rspec spec/models/user_spec.rb 下記のようにターミナルに出力されれば期待通りのテスト結果。 User nickname, email, password, password_confirmationがあれば有効であること (FAILED - 1) Failures: 1) User nickname, email, password, password_confirmationがあれば有効であること Failure/Error: expect(user).to_not be_valid expected # not to be valid # ./spec/models/user_spec.rb:11:in `block (2 levels) in ' Finished in 0.09446 seconds (files took 4.89 seconds to load) 1 example, 1 failure Failed examples: rspec ./spec/models/user_spec.rb:4 # User nickname, email, password, password_confirmationがあれば有効であること 上記のFailure/Error: expect(user).to_not be_validのように、expect(user).to_not be_validがエラーとなって、テストが失敗しています。 validationのテスト 続いてvalidationのテストを実装していきます。 今回のUserモデルでは下記のようなvalidationを実装しています。 validates :nickname, presence: true, uniqueness: true, length: { maximum: 10 } validates :password_confirmation, presence: true また、このほかにユーザーの認証にはdeviseを使用しているため、deviseが設定しているvalidationが内部的に存在しています。 （例えばemailがnil or 空文字だと無効など) ここではnicknameのvalidationテストを実装してみます。 nicknameのvalidationは下記の通り. validates :nickname, presence: true, uniqueness: true, length: { maximum: 10 } nilまたは空文字の場合は無効 (presence: true) 同じnicknameは保存できない (uniqueness: true) 文字数は最大で10文字 以上のことから、テストすべき観点は下記が想定されます。 it \"nicknameがnilの場合、無効であること\" it \"nicknameが空文字の場合、無効であること\" it \"nicknameが既に保存されている場合、無効であること\" it \"nicknameが10文字以内の場合、有効であること\" it \"nicknameが11文字以上の場合、無効であること\" ハンズオン では実際にテストを実装してみましょう。 spec/models/user_sample_1.rbを開いてください。exampleを用意していて、どのように実装すれば良いかコメントしているのでそれを参考に実装してみましょう。 require 'rails_helper' RSpec.describe User, type: :model do it \"nickname, email, password, password_confirmationがあれば有効であること\" do user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end describe 'nickname' do it 'nilの場合、無効であること' do # nicknameがnilのインスタンスを作成して、無効であることをテストする。 end it '空文字の場合、無効であること' do # nicknameが「''」のインスタンスを作成して、無効であることをテストする。（無効な場合はエラー文が含まれているかテストする） end it 'すでに使用されているnicknameの場合、保存できないこと' do # 最初にuserインスタンスを保存する。 # 次に最初に作成したuserインスタンスと同じnicknameを持ったuserインスタンスを新しく作成する。 # そのインスタンスが無効であることをテストする。（無効な場合はエラー文が含まれているかテストする） end it '10文字以内の場合、有効であること' do # nicknameが10文字のuserインスタンスを作成し、有効であるかテストする。 end it '11文字以上の場合、無効であること' do # nicknameが11文字のuserインスタンスを作成し、無効であるかテストする。（無効な場合はエラー文が含まれているかテストする） end end end 解答例 require 'rails_helper' RSpec.describe User, type: :model do # 有効な属性の場合のテスト ## 省略 describe 'nickname' do it 'nilの場合、無効であること' do user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it '空文字の場合、無効であること' do user = User.new( nickname: \"\", email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do User.create( nickname: 'Takashi', email: 'tester_1@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do user = User.new( nickname: 'TakashiKai', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKaii', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end テストを実行してみます。 ターミナル bundle exec rspec spec/models/user_sample_1_spec.rb User nickname nilの場合、無効であること 空文字の場合、無効であること すでに使用されているnicknameの場合、保存できないこと 10文字以内の場合、有効であること 11文字以上の場合、無効であること Finished in 1.19 seconds (files took 4.51 seconds to load) 5 examples, 0 failures となっていればテスト成功です。 では解説していきます。 まず、何をテストするかを明示的に示すため、describeを使用します。 describe 'nickname' do これでこのブロックはnicknameのテストを実装しているんだな、と理解できるようになります。 続いてexampleについて、'nilの場合、無効であること'を例に解説していきます。 it 'nilの場合、無効であること' do user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end 以前のテスト同様に、まずはuserインスタンスを作成しますが、今回は「nicknameがnilの場合」をテストしたいため、 nicknameをnilの状態でインスタンスを作成します。 user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) そしてvalid?メソッドを使用してuserインスタンスが有効かどうかを判定します。 user.valid? valid?メソッドは対象のオブジェクトが有効な場合はtrue、無効な場合はfalseを返し、falseの場合はerrorsの中にエラー内容を格納します。 そのエラー内容が意図したものになっているかテストをしています。 expect(user.errors[:nickname]).to include(\"を入力してください\") ※今回のアプリはエラーを日本語化しているため、「を入力してください」という少しわかりづらいメッセージになっています。 英語の場合は「can't be blank」となります。 このテストで使用しているマッチャはincludeで、引数に取ったものがexpectの引数のものに含まれているか検証しています。 ここで一つ疑問が発生します。 user.valid?でuserが無効な場合、falseを返すのであれば、「user.valid?がfalseであることを期待する」というテストではダメなのか？ 下記のようなテストでも良いように見えますね。 it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKaii', # 11文字 email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user.valid?).to eq(false) end expectの引数にuser.valid?をとり、eqマッチャを使用してuser.valid?がfalseであることを期待するというテストです。 こちらの方が先ほどのテストの方よりも一行短くなります。しかも、このテストは通ります。 では下記の場合はどうなるか考えてみましょう。 it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKai', #間違えて10文字 email: '',　　 #間違えてブランク password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user.valid?).to eq(false) end （極端なケースですが）上記のテストはnicknameは11文字以上である場合をテストしたいのに10文字になっていますが、 emailが無効な値のため、user.valid?はfalseになり、テストが通ってしまいます。 これでは「11文字以上の場合、無効であること」をテストしたことにはなりません。 今回のアプリのUserモデルのようなテストであれば記述量は少ないため、発生しにくいですが、アプリが巨大化するにつれてこのようなテスト自体のミスは必ず増えてきます。 そのときに、テストしようと思ったことが実はテストできておらず、しかもテストが通ってしまうという状況は品質低下につながるため要注意です。 今回の例では適切にエラーを検証するとテストが失敗するため、すぐに異変に気づくことができます。 it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKai', #間違えて10文字 email: '',　　 #間違えてブランク password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end テストを実行すると下記のように失敗します。 User nickname 11文字以上の場合、無効であること (FAILED - 1) Failures: 1) User nickname 11文字以上の場合、無効であること Failure/Error: expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") expected [] to include \"は10文字以内で入力してください\" # ./spec/models/user_spec.rb:66:in `block (3 levels) in ' Finished in 0.67955 seconds (files took 4.55 seconds to load) 1 example, 1 failure Failed examples: rspec ./spec/models/user_spec.rb:58 # User nickname 11文字以上の場合、無効であること expected [] to include \"は10文字以内で入力してください\"とあるようにuser.errors[:nickname]の中身が空のためテストが失敗しています。 （emailでエラーになっているため、user.errors[:nickname]は空でuser.errors[:email]の中にエラーが格納されています） DRYに書く ここまでのテストを見てきて「冗長だな」と感じた方もいらっしゃると思います。 ではRSpecをDRYに書く方法をいくつか紹介していきます。 before 今回のテストではexampleの中で何度もUser.newが登場します。 これを共有化して使用するためにはbeforeを使用します。 まずはソースコードをこのように変更します。 require 'rails_helper' RSpec.describe User, type: :model do before do @user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) end it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(@user).to be_valid end describe 'nickname' do it 'nilの場合、無効であること' do @user.nickname = nil expect(@user.errors[:nickname]).to include(\"を入力してください\") end it '空文字の場合、無効であること' do @user.nickname = \"\" @user.valid? expect(@user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do @user.save user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do @user.nickname = 'TakashiKai' expect(@user).to be_valid end it '11文字以上の場合、無効であること' do @user.nickname = 'TakashiKaii' @user.valid? expect(@user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end beforeは処理を定義すると、その処理が各exampleの実行前に実行されます。 今回の場合はUserインスタンスを作成して@userに代入しています。 テストを実行すると、各exampleの実行前に@userにインスタンスが代入されるため、example内で@userを呼び出すことができます。 あとは各exampleに適したテストを実行するだけです。 beforeのスコープはdescribeやまだ出てきていませんがcontextの中になります。 今回は最上位のdescribe内で定義しているため、すべてのexampleから@userにアクセスできますが、 これを下記のように書き換えてみます。 ## 省略 describe 'nickname' do before do @user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) end ## 省略 このようにdescribe 'nickname' do内にbeforeを定義するとこのdescribe内からしかアクセスできなくなります。 そのため、下記テストは失敗します。 it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(@user).to be_valid end let 続いてletです。変数を作成するメソッドになりますが、変数を作成するタイミングが特徴的です。 宣言した時には作成せず、その変数を呼び出した時に初めて作成されます。 先ほどのbeforeをletに置き換えてみます。 require 'rails_helper' RSpec.describe User, type: :model do let(:user) { User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) } it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(user).to be_valid end describe 'nickname' do it 'nilの場合、無効であること' do user.nickname = nil expect(user.valid?).to eq(false) end it '空文字の場合、無効であること' do user.nickname = \"\" user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do user.save new_user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) new_user.valid? expect(new_user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do user.nickname = 'TakashiKai' expect(user).to be_valid end it '11文字以上の場合、無効であること' do user.nickname = 'TakashiKaii' user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end 上記のように置き換えることができました。 では、beforeとletの違いはなんでしょうか？ beforeは各exampleの前で必ず実行されます。 対してletは宣言している箇所ではまだ処理が実行されず、変数が呼び出されて初めて、処理が実行されます。 let(:user) { User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) } 上記のようにletを宣言していますが、このときにはまだuserという変数には何も値が入っていません。 it \"nickname, email, password, password_confirmationがあれば有効であること\" do expect(user).to be_valid end 上記のexpect(user).to be_validにて、userが呼び出されたタイミングで初めてletで宣言したuser変数に値が格納されます。 つまり、beforeでは（スコープはありますが）すべてのexampleの実行前に呼び出されますが、letは変数を呼び出して初めて実行されるため、 letを使用すると不必要なデータを作成せずに済みます。 beforeで処理する内容はすべてのexampleで必要な処理を定義すべきです。例えば、「ユーザーがログインしている場合」の処理を実行したいのであれば、 そのグループのexampleでは必ずログイン状態を作成する必要があるため、 before do sign_in user end のようにすることができます。（詳細は割愛しますが、sign_inメソッドはdeviseのメソッドです。テストでも設定ファイルに記述が必要ですが使用することができます。） shoulda-matchers これはexampleを簡素に記述することができるようになる外部ライブラリです。 まずは導入しましょう。 Gemfile group :test do ## 省略 gem 'shoulda-matchers' end ターミナル bundle install rails_helperに設定を記述します。 spec/rails_helper.rb ## 省略 Shoulda::Matchers.configure do |config| config.integrate do |with| with.test_framework :rspec with.library :rails end end これで準備が整いました。 Userモデルのスペックを例にリファクタリングしてみましょう。 以前、nicknameのvalidationテストは下記のように書いていました。 describe 'nickname' do it 'nilの場合、無効であること' do user = User.new( nickname: nil, email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it '空文字の場合、無効であること' do user = User.new( nickname: \"\", email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"を入力してください\") end it 'すでに使用されているnicknameの場合、保存できないこと' do User.create( nickname: 'Takashi', email: 'tester_1@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user = User.new( nickname: 'Takashi', email: 'tester_2@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"はすでに存在します\") end it '10文字以内の場合、有効であること' do user = User.new( nickname: 'TakashiKai', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end it '11文字以上の場合、無効であること' do user = User.new( nickname: 'TakashiKaii', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) user.valid? expect(user.errors[:nickname]).to include(\"は10文字以内で入力してください\") end end end こちらをshoulda-matchersを使用して記述すると下記のようになります。 describe 'nickname' do it { is_expected.to validate_presence_of :nickname } it { is_expected.to validate_uniqueness_of :nickname } it { is_expected.to validate_length_of(:nickname).is_at_most(10) } end なんとexampleがたったの３行になってしまいました！！ is_expectedでUserのインスタンスを作成しています。 validate_presence_ofは、引数である:nicknameがnilまたはブランクだったときに無効であるかをチェックしています。 validate_uniqueness_ofは、同じくnicknameが同一のデータが作成できないことをチェックしていて、 validate_length_of(:nickname).is_at_most(10)は10文字以内は可、11文字以上は作成できないことをチェックしています。 本当にテストできているか確かめるには、toをto_notに置き換えて実行してみましょう。 例えばit { is_expected.to validate_length_of(:nickname).is_at_most(10) }をit { is_expected.to_not validate_length_of(:nickname).is_at_most(10) }にして実行すると下記のようなエラーになります。 Expected User not to validate that the length of :nickname is at most 10, but this could not be proved. After setting :nickname to ‹\"xxxxxxxxxx\"›, the matcher expected the User to be invalid, but it was valid instead. ‹\"xxxxxxxxxx\"›を見るとマッチャが自動的に10文字の文字列を作成してインスタンスを作成していることがわかります。 この10文字を当てはめて実行したとき、User to be invalid, but it was valid instead.とあるように Userインスタンスは作成できないことを期待していますが、正常に作成できてしまっています。 つまり、it { is_expected.to validate_length_of(:nickname).is_at_most(10) }は正常に働いており、正しくテストできていると言えます。 .is_at_most(10)の数字を9や11などにしたときにどのように動作するか確かめてもいいかもしれません。 他にもたくさんのマッチャがあるので是非下記を参考にしてみてください。 https://github.com/thoughtbot/shoulda-matchers ハンズオン では一度ここまでの知識でuser_spec.rbをリファクタリングしてみましょう。 spec/models/user_sample_2.rbを開いてください。exampleを用意していて、どのように実装すれば良いかコメントしているのでそれを参考に実装してみましょう。 require 'rails_helper' RSpec.describe User, type: :model do it \"nickname, email, password, password_confirmationがあれば有効であること\" do user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end describe 'アソシエーション' do # shoulda-matchersを使用して、postモデルとのアソシエーションをテストする。 # shoulda-matchersを使用して、commentモデルとのアソシエーションをテストする。 end describe 'nickname' do it { is_expected.to validate_presence_of :nickname } it { is_expected.to validate_uniqueness_of :nickname } it { is_expected.to validate_length_of(:nickname).is_at_most(10) } end describe 'email' do # shoulda-matchersを使用して、emailが必須項目であることをテストする。 # shoulda-matchersを使用して、emailがユニークであることをテストする。 it 'emailの形式ではない場合、無効な状態であること' do # emailが正しい形式ではないuserインスタンスを作成して、無効であるかテストする。 end it 'emailは全角文字を使用する場合、無効な状態であること' do # emailが全角入力のuserインスタンスを作成して、無効であるかテストする。 end end describe 'password' do # shoulda-matchersを使用して、passwordが必須項目であることをテストする。 # shoulda-matchersを使用して、passwordが6文字以上128文字以内で有効なことをテストする。 # shoulda-matchersを使用して、password_confirmationが必須項目であることをテストする。 it 'passwordとpassword_confirmationが不一致の場合、無効な状態であること' do # passwordの値とpassword_confirmationの値が一致しないuserインスタンスを作成して、無効であるかテストする。 end end end 解答例 require 'rails_helper' RSpec.describe User, type: :model do it \"nickname, email, password, password_confirmationがあれば有効であること\" do user = User.new( nickname: 'Takashi', email: 'tester@example.com', password: 'p@ssword!!', password_confirmation: 'p@ssword!!', ) expect(user).to be_valid end describe 'アソシエーション' do it { is_expected.to have_many :posts } it { is_expected.to have_many :comments } end describe 'nickname' do it { is_expected.to validate_presence_of :nickname } it { is_expected.to validate_uniqueness_of :nickname } it { is_expected.to validate_length_of(:nickname).is_at_most(10) } end describe 'email' do it { is_expected.to validate_presence_of :email } it { is_expected.to validate_uniqueness_of(:email).case_insensitive } it 'emailの形式ではない場合、無効な状態であること' do 　　　user = User.new( 　　nickname: 'Takashi', 　　email: 'example_no_email', # 無効なemailアドレス 　　password: 'p@ssword!!', 　　password_confirmation: 'p@ssword!!', 　　　　) user.valid? expect(user.errors[:email]).to include(\"は不正な値です\") #invalid end it 'emailは全角文字を使用する場合、無効な状態であること' do user = User.new( nickname: 'Takashi', 　　 email: 'ｅｘａｐｌｅ@gmail.com', # 全角 　　 password: 'p@ssword!!', 　　 password_confirmation: 'p@ssword!!', 　　　　) user.valid? expect(user.errors[:email]).to include(\"は不正な値です\") #invalid end end describe 'password' do it { is_expected.to validate_presence_of :password } it { is_expected.to validate_length_of(:password).is_at_least(6).is_at_most(128) } it { is_expected.to validate_presence_of :password_confirmation } it 'passwordとpassword_confirmationが不一致の場合、無効な状態であること' do user = User.new( nickname: 'Takashi', 　　 email: 'ｅｘａｐｌｅ@gmail.com', 　　 password: 'password', 　　 password_confirmation: 'password_confirmation', # passwordと異なる 　　　　) user.valid? expect(user.errors[:password_confirmation]).to include(\"とパスワードの入力が一致しません\") #confirmation end end end 非常に簡素にまとまりましたね！！ テストデータの作成方法 テストを作成するにあたり、テストデータの作成は非常に重要です。 テストが膨大になればなるほどテストデータの作成コストはどんどん膨らんでいきます。 そこで、RailsではFactorybotというライブラリを使用して簡単にテストデータを作成する方法が用意されています。 まずはFactorybotを導入します。 Gemfile group :development, :test do ## 省略 gem 'factory_bot_rails' end ターミナル bundle install 続いてジェネレータを使用してファイルを作成していきます。Userモデルのテストデータを作成したい場合は下記を実行します。 ターミナル rails g factory_bot:model user するとspec/factories/users.rbというファイルが作成されます。 例えば下記のように記述します。 FactoryBot.define do factory :user do nickname { \"Takashi\" } email { \"example@gmail.com\" } password { \"password\" } password_confirmation { password } end end では実際にPostモデルスペックを例にこのテストデータを使用してみます。 describe Post do let(:user) { create(:user) } it 'text, userがあれば有効であること' do post = Post.new( text: '投稿のテキスト', user: user ) expect(user).to be_valid end ## 省略 end 上記のようにcreateメソッドを使用するとfactoryのデータを参照して作成することができます。 createは引数にシンボルをとり、この値は、spec/factories配下のファイル内のfactory :user doを見つけて作成しています。 つまり、今回のケースではspec/factories/users.rbでfactory :user doと定義されているため、 post_spec.rbにてcreate(:user)とするとlet(:user)の変数に User.new( nickname: \"Takashi\", email: \"example@gmail.com\" password: \"password\" password_confirmation: \"password\" ) が代入されることになります。 また、create(:user)とするとspec/factories/users.rbの定義をもとにuserインスタンスを作成しますが、データを上書きすることもできます。 例えばnicknameを違う値にしたい時は let(:user) { create(:user, nickname: \"Kato\") } とすることで、\"Takashi\"ではなく\"Kato\"で作成されます。 ※詳細は割愛しますが今回のアプリではFactorybotでデータ作成する際に、併せてFakerというライブラリを使用しています。 上記では毎回同じテストデータになってしまいますが、Fakerを使用するとランダムな値を簡単に作成することができたり、 email形式やurl形式のデータを簡単に作成してくれるため、非常に便利です。 詳細は下記GitHubをご覧ください。 https://github.com/faker-ruby/faker 3. 外部APIテスト 今回のアプリではスラックと連携しており、投稿したときに自動的にスラックのチャネルにチャットを投下する機能があります。 メッセージを投下する(Post.create） Postモデルのafter_save :start_slack_syncが呼ばれてjobが実行される jobがPostモデルのslack_sync!メソッドを呼び出す。 Slack::SendPostServiceのsend_postメソッドが実行されてスラックにメッセージを投下する。 という流れです。 今回は外部APIテストとしてSlack::SendPostServiceのテストを実装します。 ※詳細は割愛しますが、スラックに連携する際にslack-notifierというライブラリを使用しています。詳しく知りたい方は下記を参考にしてください。 https://github.com/slack-notifier/slack-notifier VCRの導入 外部APIの連携テストの際はスタブを使用することが多いと思います。 簡単にスタブを作成できるVCRというライブラリがあるのでご紹介します。 ではまずは導入していきます。 Gemfile group :test do ## 省略 gem 'webmock' gem 'vcr' end VCRを使用する際は内部的にwebmockというライブラリも使用するため、一緒にインストールします。 ターミナル bundle install spec_helper.rbを編集して設定を記述していきます。 spec/spec_helper.rb require 'vcr' require 'webmock' RSpec.configure do |config| ## 省略 end VCR.configure do |c| c.cassette_library_dir = 'spec/vcr' c.hook_into :webmock c.configure_rspec_metadata! end これで準備が整いました！ ではテストを実装していきます。 今回テストする処理はapp/servise/slack配下のsend_post_service.rbというファイルです。 そのため、テストはspec/servise/send_post_service_spec.rbに作成します。 require 'rails_helper' describe Slack::SendPostService do describe 'slack alignment' do context \"#send_post\" do it 'post to slack' do ## テストを書く end end end end まずは上記のように外枠を書いてみました。 テストする箇所はdescribe Slack::SendPostService doとして明示しています。 テストする内容はdescribe 'slack alignment' doとしていて、スラックとの連携テストだよと記載しています。 context \"#send_post\" doではsend_postメソッドのテストを実装することを示しています。 あるメソッドをテストする時は、慣習的に#メソッド名とすることが多いです。 最後にexampleをit 'post to slack' doとしています。 では実際にexampleの中身を書いていきましょう。 その前に簡単にSendPostServiceの中身を見てみましょう。 module Slack class SendPostService def initialize(user_name) webhook_url = ENV['SLACK_WEBHOOK_URL'] channel = \"##{ENV['CHANNEL_NAME']}\" @client ||= Slack::Notifier.new(webhook_url, channel: channel, username: user_name) end def send_post(message) @client.ping(message) end end end Slack::SendPostServiceをinitializeするときにuserのnicknameを引数に取り、@clientをを作成します。 これは先ほどのslack-notifierライブラリを使用していますが、Slack::Notifier.newインスタンスであり、 引数にスラックのwebhook_url、メッセージを投下するチャンネル名、そしてusernameを指定しています。 そしてこの@clientにpingメソッドを使用すると、該当のスラックのチャンネルにメッセージを投下するという仕組みです。 それを踏まえてテストを実装すると下記のようになります。 it 'post to slack', :vcr do response = Slack::SendPostService.new('user_nickname').send_post('test_message') expect(response.first.message).to eq(\"OK\") end まず、response = Slack::SendPostService.new('user_nickname').send_post('test_message')でSlack::SendPostServiceのインスタンスを作成して、send_postメソッドを呼び出しています。これでスラックにメッセージを投下することができます。 投下した後はAPIからレスポンスが返されるため、それをresponseに代入しています。 メッセージの投下が成功すればresponseの中に\"OK\"というメッセージが含まれるはずなのでexpect(response.first.message).to eq(\"OK\")として検証をしています。 ではテストを実行してみましょう。 （事前にSlack APIの設定およびenvファイルの作成と環境変数の設定が必要です） ターミナル rspec spec/service/send_post_service_spec.rb 正常に終了すれば下記のようなログが出ると思います。 Slack::SendPostService slack alignment #send_post post to slack Finished in 0.52359 seconds (files took 4.99 seconds to load) 1 example, 0 failures お気づきの方もいらっしゃるかもしれませんが、先ほどのexampleを作成したときに、:vcrと記述しています。 it 'post to slack', :vcr do response = Slack::SendPostService.new('user_nickname').send_post('test_message') expect(response.first.message).to eq(\"OK\") end it 'post to slack', :vcr doの箇所です。こうすることでvcrを使用することができます。 この状態でテストを実行すると、spec配下にvcr/Slack_SendPostService/slack_alignment/_send_post/post_to_slack.ymlというファイルが自動生成されると思います。 中身はこのようになっています。 --- http_interactions: - request: method: post uri: https://hooks.slack.com/services/************* body: encoding: US-ASCII string: payload=*************** headers: Accept-Encoding: - gzip;q=1.0,deflate;q=0.6,identity;q=0.3 Accept: - \"*/*\" User-Agent: - Ruby Content-Type: - application/x-www-form-urlencoded response: status: code: 200 message: OK headers: Date: - Mon, 28 Mar 2022 09:25:14 GMT Server: - Apache X-Powered-By: - HHVM/4.153.0 X-Frame-Options: - SAMEORIGIN Access-Control-Allow-Origin: - \"*\" Referrer-Policy: - no-referrer X-Slack-Backend: - r Strict-Transport-Security: - max-age=31536000; includeSubDomains; preload Vary: - Accept-Encoding Content-Length: - '22' Content-Type: - text/html X-Envoy-Upstream-Service-Time: - '192' X-Backend: - main_normal main_bedrock_normal_with_overflow main_canary_with_overflow main_bedrock_canary_with_overflow main_control_with_overflow main_bedrock_control_with_overflow X-Server: - slack-www-hhvm-main-iad-98d1 X-Slack-Shared-Secret-Outcome: - no-match Via: - envoy-www-iad-9tfu, envoy-edge-nrt-3w6t X-Edge-Backend: - envoy-www X-Slack-Edge-Shared-Secret-Outcome: - no-match body: encoding: ASCII-8BIT string: ok recorded_at: Mon, 28 Mar 2022 09:25:14 GMT recorded_with: VCR 6.0.0 これはテストを実行した際に、スラックAPIを実際に叩いて通信をしていて、その時のリクエストとレスポンスをymlファイルとしてまとめたものになります。 このファイルが作成された後にもう一度テストすると、今度はスラックAPIを叩くことなく、このファイルをもとにレスポンスを返してくれます。 つまり、VCRは、初回のみ実際にAPIにリクエストを行い、そのリクエストと、レスポンスをもとにymlファイルを自動生成し、以降のテストはそれをスタブとして値を返すというものです。 そのため、テストのたびに余計なリクエストを投げることがなくなります。 また、自分でスタブを実装する必要がなく、自動で生成してくれるため非常に便利です。 ただし、初回だけ通信が必要になるため、その通信環境が整っていなかったり、何かしらの理由でリクエストが失敗してしまったりすると、その状態でymlファイルを作成してしまうため、 正しくテストができない可能性があります。その場合は従来通りwebmock等を使用したスタブを自身で作成することを検討する必要があります。 何かしらの理由で想定外のレスポンスが返ってきた場合、vcrディレクトリを削除して再度実施すれば、もう一度実際にリクエストをしてファイルを自動生成してくれます。 まとめ 単体テストの実装をモデル・外部APIを例に実装してみました。またリファクタリングのテクニックについてもご紹介しました。 こちらがRSpecの基礎となっていくので是非抑えていただいて以降のテストに活かしていただければと思います。 "},"Section_4.html":{"url":"Section_4.html","title":"4.結合テスト(IT)","keywords":"","body":"結合テスト（IT） 本セクションで行うこと 今回取り上げる結合テストについて Request specの解説 今回取り上げる結合テストについて 結合テストは、Integration Test(統合テスト)とも呼ばれ、システム開発において単体レベルで開発した機能が組み合わさって動作した時、期待される動作をするかどうかをテストします。結合テストは、実施する対象によって内部結合・外部結合に分かれます。 内部結合・・・ システム内部の機能同士を組み合わせてテストを行う外部結合・・・ システム内部の機能とシステム外部の機能を組み合わせてテストを行う 今回取り上げる結合テストは「内部結合」になります 今回の投稿アプリでは、以下３つの機能があります。 ユーザー機能(users_controller)ユーザー作成、ユーザー認証（ログイン・ログアウト） 投稿機能(posts_controller)投稿の新規作成、投稿の編集、投稿の一覧表示、投稿削除 コメント機能(comments_controller)対象の投稿に対してコメントの作成 内部結合では、３つの機能の間の連携部分が期待される動きをするか？というテストをします。 具体的な観点は以下です。 コントローラーへのリクエストが通ること 期待されるレスポンスが返却されること Request specの解説 Request specを使うと、以下のテストができるようになります。 HTTPリクエストのテストができる 複数コントローラーの複数のリクエストがテストできる 複数のセッションでリクエストを指定できる 以下、Request specファイルの生成コマンド rails g rspec:request ファイル名 投稿機能の結合テスト(posts_spec.rb)を例に実際のテストコードを確認していきます。 require 'rails_helper' RSpec.describe 'Posts', type: :request do ~~~~~~~~~~~①~~~~~~~~~~~~ let(:user) { create(:user, nickname: 'Takashi') } let(:post_instance) { create(:post, user: user, text: 'PostRequestTest', image: 'https://example_image_url') } ~~~~~~~~~~~①~~~~~~~~~~~~ describe '投稿一覧' do ~~~~~~~~~~~②~~~~~~~~~~~~ subject { get posts_url } ~~~~~~~~~~~②~~~~~~~~~~~~ context 'ログインしている場合' do ~~~~~~~~~~~③~~~~~~~~~~~~ before do sign_in user post_instance end ~~~~~~~~~~~③~~~~~~~~~~~~ ~~~~~~~~~~~④~~~~~~~~~~~~ it_behaves_like 'return_response_status', 200 ~~~~~~~~~~~④~~~~~~~~~~~~ it 'レスポンスに適切な投稿内容を含むこと' do subject aggregate_failures do expect(response.body).to include 'PostRequestTest :Takashiの投稿' expect(response.body).to include '投稿者Takashi' end end end ~~~~省略~~~~~ 3.1 ユーザーがログインしている場合は投稿一覧のリクエストが成功すること ①テストデータとして、ログインユーザーと投稿を定義②subject(テスト対象のオブジェクト)は、投稿一覧のリクエスト処理　Request specでは直接ルーティング名を指定することができます。③テスト前にテストデータのユーザーでログイン処理とlet（post_instance）を呼び出しておく④リクエストが通ることを確認するので、HTTPレスポンスのステータスが200であることが期待値it_behaves_likeは、新しいコンテキスト(context 'xxx'do ... endのこと)を自動生成して、そこにテストケースを埋め込みます。return_response_statusは、同じテストコードの重複を避けるためにshared_examplesを使ってまとめています。中身のテストコードは、別ファイルで定義しています。mirameetVol27/spec/support/examples/return_response_status.rb RSpec.shared_examples 'return_response_status' do |status_no| it \"#{status_no}レスポンスを返すこと\" do subject expect(response.status).to eq status_no end end shared_examplesなしのコード： context 'behaves like a return_response_status' do it \"200レスポンスを返すこと\" do expect(response.status).to eq 200 end end 3.2 投稿一覧のレスポンスに適切な投稿内容を含んでいること require 'rails_helper' RSpec.describe 'Posts', type: :request do let(:user) { create(:user, nickname: 'Takashi') } let(:post_instance) { create(:post, user: user, text: 'PostRequestTest', image: 'https://example_image_url') } describe '投稿一覧' do subject { get posts_url } context 'ログインしている場合' do before do sign_in user post_instance end it_behaves_like 'return_response_status', 200 it 'レスポンスに適切な投稿内容を含むこと' do ~~~~~~~~~~~①~~~~~~~~~~~~ subject ~~~~~~~~~~~①~~~~~~~~~~~~ aggregate_failures do ~~~~~~~~~~~②~~~~~~~~~~~~ expect(response.body).to include 'PostRequestTest :Takashiの投稿' expect(response.body).to include '投稿者Takashi' ~~~~~~~~~~~②~~~~~~~~~~~~ end end end ~~~~省略~~~~~ ①subject(テスト対象のオブジェクト)は先ほどと同じ、投稿一覧のリクエスト処理②返却されたレスポンスのボディに投稿の内容とhtmlを含んでいるか確認します。response.bodyの内容を検証しています。 "},"Section_5.html":{"url":"Section_5.html","title":"5.システムテスト(ST)","keywords":"","body":"システムテスト(ST) 本セクションで行うこと システムテストについて System spec解説 システムテストについて システムテスト(System Test)は、要件定義書に記載した要件をクリアしているか?つまりアプリ全体が一つのシステムとして期待される動きをするのか?を確認するテストになります。これまで説明した単体テスト、結合テストとは、詳細設計、基本設計で記載した要件をクリアしているかどうかを確認していました。このような形のテストモデルを「V字モデル」と呼びます。 では、実際にシステムテストを行う際はどのようにテストケースを実施すれば良いでしょうか?システムテストの手法としていくつかありますが、今回はシナリオテストを行います。 シナリオテストは、実際のユーザーの行動をシナリオ化してテストを行います。投稿機能を例に考えてみましょう。 投稿機能におけるシステムテスト： 1. ユーザーは投稿する 2. ユーザーは投稿の編集をする 3. ユーザーは投稿の削除をする 4. ユーザーは自分の投稿にコメントをする 5. ユーザーは他人の投稿を閲覧し、コメントをする 6. ...以下省略... System spec解説 RSpecでは、システムテストとして行うテストをSystem specと呼んでいます。 System specでは、ユーザーの動きをコードに起こしてテストする為に、「Capybara」と言うgem(ライブラリ）を使います。Capybaraは、Rails5.1以降では標準インストールされています。Capybaraは、指定したページにアクセスしたり、フィールドに入力したり、ボタンをクリックしたり、ブラウザの操作を可能にします。 先ほどの投稿機能のシステムテストケースを使って、実際のコードを確認していきましょう！ require 'rails_helper' RSpec.feature 'Posts', type: :system do background do driven_by(:rack_test) end ~~~~~~~~~~~①~~~~~~~~~~~~ let(:user_a) { create(:user, nickname: 'Takashi') } ~~~~~~~~~~~①~~~~~~~~~~~~ let(:user_b) { create(:user, nickname: 'Satoshi') } let!(:post) { create(:post, text: 'hello world', user: user_a)} ~~~~~~~~~~~②~~~~~~~~~~~~ before do sign_in_as user_a end ~~~~~~~~~~~②~~~~~~~~~~~~ describe '投稿の作成' do scenario 'ユーザーは新しい投稿を作成する' do ActiveJob::Base.queue_adapter = :test expect { ~~~~~~~~~~~③~~~~~~~~~~~~ click_link_or_button '投稿する' fill_in 'post_text', with: 'sample_text' click_button 'commit' post = Post.find_by_text_and_user_id('sample_text :Takashiの投稿', user_a.id) ~~~~~~~~~~~③~~~~~~~~~~~~ ~~~~~~~~~~~④~~~~~~~~~~~~ aggregate_failures do expect(current_path).to eq posts_path expect(page).to have_content 'sample_text' expect { SlackSyncJob.perform_later(post) }.to have_enqueued_job.with(post) end ~~~~~~~~~~~④~~~~~~~~~~~~ }.to change(user_a.posts, :count).by(1) end ~~以下省略~~ 3.1. ユーザーは投稿する ①投稿する為にユーザーを定義 ②テスト実施前に、ユーザーのログイン処理を行う ③テスト対象はユーザーは投稿するなので、Capybaraのメソッドでブラウザ操作して投稿処理をする 上記では、「投稿する」ボタンを押下して遷移先で、\"sanple_text\"と投稿欄に入力して、投稿ボタンを押下しています。 ③で使用しているCapybaraメソッドclick_link_or_button　'対象要素のIDやテキスト'　・・・指定したボタンもしくはリンクを探してクリックする。 fill_in '対象要素のnameやID', with: 'フィールドに入力する文字'　・・・指定した要素を探して、with以降で指定した文字を入力する。 click_button　'対象要素のIDやname'　・・・指定したボタンを探してクリックする。 ④テスト対象（③）に対して、遷移先のパスが合っているか、投稿した内容を表示しているか、スラック通知処理はできているかを確認 ④で使用しているCapybaraメソッドcurrent_path・・・現在表示しているページのパスを返す。page・・・現在表示しているページのオブジェクト。 補足：aggregate_failures do...endは、これで囲まれたexpectは、expectの評価で失敗しても次のexpectを実行することができるようになります。これまでのRSpecだと、一つのexampleにつき複数のexpectで書くと失敗した時にそれ以降のexpectが実行されませんでしたが、これにより一つのexpamleに複数のexpectを書くことが出来ます。 "},"Section_6.html":{"url":"Section_6.html","title":"6.AWS CodeBuildでビルドを実行しみよう！","keywords":"","body":"AWS CodeBuildでテスト＆ビルドする 本セクションで行うこと AWS CodeBuildの解説 ビルドプロジェクトを作成する CodeBuildでビルドを実行する ※以下のハンズオンは、AWSサービスの料金（100円程度）が発生します。実施後の費用発生を防止する為にに必ず最後の「CloudFormationの削除」を実施してください。 AWS CodeBuildの解説 AWSで提供されているクラウドサーバー上で、プロジェクトのテストとビルドができるサービス。 Rubyの他にJava、Go, pythonなどに対応。 また、他のサービス（AWS CodeCommitやCodeDeploy）と組み合わせて利用することも可能。 AWS CodeBuildの仕組み AWS CodeBuildは、「ビルドプロジェクト」を元にビルドを行う。 ビルドプロジェクト・・・ソースコードの指定やビルド環境の指定などビルドに関わる情報のこと。AWSコンソールから作成できる。 AWS CodeBuildの処理の流れ AWSコンソールからCodeBuildを実行すると、以下の流れでビルドが行われる。 ビルドプロジェクトに基づきビルド環境を作成 ビルド環境で、ソースコードをダウンロード後、buildspec.ymlで設定したコマンドを実行してソースのコンパイル・テスト・ビルドを行う。 ビルド出力がある場合は、S3にデプロイ可能なアーティファクトをアップロードされる。 １〜３のログは、AWS CloudWatch Logsに送信される。 buildspec.yml ビルド環境で実行するコマンドなどを記載するyaml形式のファイル。パス：mirameetVol27/buildspec.yml version: 0.2 ・・・buildspecのバージョンを指定（最新の0.2を使用） phases: install: ・・・インストールの段階で実行するコマンドを設定する。主にビルド環境で使用するパッケージのインストールなどに使用。 runtime-versions: docker: 19 ・・・ 今回はdockerを使用しているのでdockerのバージョン19を指定（※１）。 commands: pre_build: ・・・・ビルドの前に実行するコマンドを設定する。主にnpmパッケージのインストールやgemのインストールなどに使用。 - echo PRE_BUILD Start - echo PRE_BUILD Start - docker-compose -f docker_compose_test.yml build ・・・　dockerをビルドする。 - docker-compose -f docker_compose_test.yml up -d - docker-compose -f docker_compose_test.yml run app rails db:create - docker-compose -f docker_compose_test.yml run app rails db:migrate - docker-compose -f docker_compose_test.yml run app rails assets:precompile build: ・・・ビルド時に実行するコマンドを設定する。主にテストを行う。 commands:† - echo BUILD start - docker-compose -f docker_compose_test.yml run app bundle exec rake spec ・・・テストを実行する。 ※１バージョンはこちらを参照 ビルドプロジェクトを設定する 実際の現場では、テスト環境用のDBが用意されていることがあると思います。CodebuildはVPC内に設置することも可能なので、同じVPC内にRDSを設置することでCodeBuildからRDSに接続してテストを実行することができます。 今回は実際の現場で使えそうな利用方法として、テスト用のRDSに接続してビルドを実行したいと思います。 今回使用するAWSのアーキテクトの確認 ポイント VPCのパブリックサブネットにはNatGatewayを設置し、インターネット接続を可能にしておく CodeBuildとRDSはプライベートサブネットに設置する RDSのセキュリティグループに、CodeBuildを設定するサブネットからのアクセスを追加する。（この設定によってCodeBuildはRDSに接続可能になる） CodeBuild以外の上記のアーキテクトは、CloudFormationを用意しているのでサクッと作成していきましょう！ AWSにログイン & CloudFormationのスタック作成画面に移動 AWSにログイン後に、上部の検索フォームでCloudFormationのサービスへ移動します。 「スタックの作成」をクリックすれば、スタック作成画面へ遷移します。 テンプレートの指定 最初にvpcのスタックを作成します。テンプレートファイルのアップロードを選択、project直下にあるvpc.ymlを選択し、「次へ」をクリックします。ファイルパス: mirameetVol27/vpc.yml スタックの詳細設定 「スタックの名前」はmirameet-27-vpcパラメータの「PJPrefix」はmirameetとし、「次へ」をクリックします。 スタックの作成 ステップ４のレビューまで「次へ」をクリックします。ステップ４まできたら下部にある「スタックの作成」をクリックします。作成が完了すると、ステータスはCREATE_COMPLETEになります。 RDSのスタック作成 スタックの作成が完了したら、上記と同じ流れでRDSのスタックを作成します。テンプレートはrds.ymlファイルパス： mirameetVol27/rds.yml 「スタックの名前」はmirameet-27-rds、パラメータの「PJPrefix」はmirameetで作成します。 ビルドプロジェクトの作成 ビルドプロジェクトでVPCを指定する必要があるので、事前にVPC・サブネット・RDSを作成しておきましょう。AWS Codebuildのビルドプロジェクトの作成画面です。 プロジェクト名・・・ プロジェクト名を指定する（今回はmirameetVol27) ソースプロバイダ・・・GitHubやBitbucketなど　ソース共有ツールを指定する（今回はGitHub) リポジトリ・・・GitHub の個人用アクセストークンで接続するを選択 GitHub の個人用アクセストークン・・・以下を参考に個人用アクセストークンを作成して貼り付けて「トークンの保存」をクリックGitHubの個人用アクセストークンの作成 ソースのリポジトリの種別（PublicリポジトリかPrivateリポジトリか）を選択・・・GitHubの接続が完了したら選択する（今回はパブリックリポジトリ）https://github.com/miracleave-ltd/mirameetVol27 GitHubリポジトリ・・・対象のリポジトリを選択 環境イメージ・・・AWSの用意している環境かDockerを指定する オペレーティングシステム・・・OSを指定する（今回は、Ubuntu) ランタイム・・・ランタイムを選択（Standardを選択） イメージ・・・イメージを選択(aws/codebuild/standard:4.0) 特権付与・・・docker-composeでビルドする際はチェックを入れる VPC・・・事前に作成したVPCを選択 サブネット・・・プライベートサブネット(mirameet-private-subnet-a)を選択 セキュリティグループ・・・CodeBuild用のセキュリティグループを選択 環境変数・・・環境変数を設定（ビルド環境に設定される） RDS_USER : dbuser RDS_HOSTNAME : RDSのエンドポイントをコピペ RDS_PASSWORD : dbpassword RDS_PORT : 3306 CHANNEL_NAME : testpost SLACK_WEBHOOK_URL : SlackのWebhook URLをコピペ SLACK_WEBHOOK_URLの作成はこちらを参考に作成してください。RDSのエンドポイントは、Amazon RDSサービスで左ペインの「データベース」をクリック、データベース一覧に遷移するのでmirameet-rdsをクリック後、「接続とセキュリティ」タブに記載があります。 ビルド仕様・・・ビルドコマンドの設定（今回はBuildspecファイルを使用する） 最後に、ビルドプロジェクトを作成するをクリックして作成します！ CodeBuildでビルドを実行する ビルドプロジェクト一覧から、プロジェクトをクリック 「ビルドを開始」ボタンをクリック ビルドには５分ほどかかります。成功すると、ビルドステータスに「成功」と表示されます。 ログは以下のように出力されます。 CloudFormationの削除（費用発生を防ぐ為に必ず実施してください） CodeBuildは、ビルド時間によって費用が発生する（従量課金）なので、削除しなくても料金は発生しません。CloudFormationはNatGateWayやRDSで料金が発生する為、削除をお願いします。 スタックの一覧から、削除対象を選択、削除をクリックすると削除が始まります。 ステータスがDELETE_COMPLETEになると削除完了です。 "},"Section_7.html":{"url":"Section_7.html","title":"7.まとめ","keywords":"","body":"まとめ 本日のゴール(おさらい) 1.1. RSpecでできること・できないことが分かる。 できること 単体テスト・結合テスト・システムテストができる。 できないこと システムテストの中ではRSpecできないテスト（システムテストで行うセキュリティテストや負荷テスト等）がある。 1.2. 現場で使えるRSpecの使い方が分かる。 単体テストでは、基本的なRSpecの使い方を説明しました。 結合テストでは、Request Specを使ってHTTPリクエストのテストが可能になりました。 システムテストでは、Capybaraを使ってブラウザを操作させるテスト（シナリオテスト）が可能になりました。 1.3. RSpecを使うメリットとデメリットが分かるようになる。 メリット RSpecを使うことでテストの実施はRSpecに任せられる。 運用保守フェーズになると、既存機能のデグレを防止できる。 テストコードを一度作成すると、仕様変更がない限り継続利用できるのでテストの工数が抑えられます。 デメリット RSpecの学習コストがかかる。 開発時にテストコードも実装するので開発工数が増加する。 "}}